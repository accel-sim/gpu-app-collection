#include <stdio.h>
#include <sys/time.h>
#include "cuda.h"
#include <string.h>

#define MAX_ARGS 10
#define REC_LENGTH 49 // size of a record in db

#ifndef REC_WINDOW
 #define REC_WINDOW 15000 // number of records to take in at a time
#endif

#define LATITUDE_POS 28	// character position of the latitude value in each record
#define OPEN 10000	// initial value of nearest neighbors

struct neighbor
{
  	char entry[REC_LENGTH];
  	float dist;
};

/**
* Kernel
* Executed on GPU
* Calculates the Euclidean distance from each record in the database to the target position
*/
__global__ void euclid(char *data, float x2, float y2,float *z, int N, int W, int L_POS)
{
	int idx=blockIdx.x*blockDim.x+threadIdx.x;
	float tmp_lat=0.0, tmp_long=0.0;
	int position = ( idx * W ) + L_POS - 1;	
	
	if(idx < N) {
		char temp1[5];
		for( int i = 0 ; i < 5 ; i++ ) {
			temp1[i] = data[position+i];
		}
		char temp2[5];
		for( int i = 0 ; i < 5 ; i++ ) {
			temp2[i] = data[position+6+i];
		}
		
		int dig1, dig2, dig3, dig_1;
		if( temp1[0] == ' ' ) { dig1 = 0; }
		else {
			dig1 = temp1[0] - 48;
			tmp_lat += dig1 * 100;
		}
		if( temp1[1] == ' ' ) { dig2 = 0; }
		else {
			dig2 = temp1[1] - 48;
			tmp_lat += dig2 * 10;
		}
		if( temp1[2] == ' ' ) { dig3 = 0; }
		else {
			dig3 = temp1[2] - 48;
			tmp_lat += dig3 * 1;
		}
		dig_1 = temp1[4] - 48;
		tmp_lat += (float) dig_1 / 10;

		if( temp2[0] == ' ' ) { dig1 = 0; }
		else {
			dig1 = temp2[0] - 48;
			tmp_long += dig1 * 100;
		}
		if( temp2[1] == ' ' ) { dig2 = 0; }
		else {
			dig2 = temp2[1] - 48;
			tmp_long += dig2 * 10;
		}
		if( temp2[2] == ' ' ) { dig3 = 0; }
		else {
			dig3 = temp2[2] - 48;
			tmp_long += dig3 * 1;
		}
		dig_1 = temp2[4] - 48;
		tmp_long += (float) dig_1 / 10;

		z[idx]=sqrt(((tmp_lat-x2)*(tmp_lat-x2))+((tmp_long-y2)*(tmp_long-y2)));
	}
}

/**
* This program finds the k-nearest neighbors
* Usage:	./nn <filelist> <num> <target latitude> <target longitude>
*			filelist: File with the filenames to the records
*			num: Number of nearest neighbors to find
*			target lat: Latitude coordinate for distance calculations
*			target long: Longitude coordinate for distance calculations
* The filelist and data are generated by hurricane_gen.c
* REC_WINDOW has been assigned to read in a large number of records to increase work
*/
int main(int argc, char* argv[])
{
	FILE   *flist,*fp;
	int    i=0,j=0, k=0, rec_count=0, done=0;
	char   sandbox[REC_WINDOW * REC_LENGTH], dbname[64];
	struct neighbor *neighbors = NULL;
	float target_lat, target_long;
	char* goldfile;
	if(argc < 6)
	{
		fprintf(stderr, "Invalid set of arguments\n");
		exit(-1);
	}

	flist = fopen(argv[1], "r");

	if(!flist)
	{
		printf("error opening flist\n");
		exit(1);
	}

	k = atoi(argv[2]);
	target_lat = atof(argv[3]);
	target_long = atof(argv[4]);
	goldfile = argv[5];
	neighbors = (struct neighbor*) malloc(k*sizeof(struct neighbor));

	if(neighbors == NULL)
	{
		fprintf(stderr, "no room for neighbors\n");
		exit(0);
	}
  
	for(j=0;j<k;j++)
	{
		neighbors[j].dist = OPEN;
	}

	/**Main processing **/
	if(fscanf(flist, "%s\n", dbname) != 1)
	{
		fprintf(stderr, "error reading filelist\n");
		exit(0);
	}

	fp = fopen(dbname, "r");  
	if(!fp)
	{
		printf("error opening flist\n");
		exit(1);
	}	

        //Pointers to host memory
	float *z;
	//Pointers to device memory
	float *z_d;
	char *data;

	/**
	* Allocate memory on host and device
	*/
	z  = (float *) malloc(REC_WINDOW * sizeof(float));
	cudaMalloc((void **) &data, sizeof(char) * REC_WINDOW * REC_LENGTH);	
	cudaMalloc((void **) &z_d, sizeof(float) * REC_WINDOW);
	for(unsigned i=0; i<REC_WINDOW * REC_LENGTH;i++)
	{
		sandbox[i]=' ';
	}
	while(!done) {
		/**
		* Read in REC_WINDOW records of length REC_LENGTH
		* If this is the last file in the filelist, then done
		* else open next file to be read next iteration
		*/
		rec_count = fread(sandbox, REC_LENGTH, REC_WINDOW, fp);
		if(rec_count != REC_WINDOW) {
			if(!ferror(flist)) {// an eof occured
				fclose(fp);

				if(feof(flist))
					done = 1;
				else {
					if(fscanf(flist, "%s\n", dbname) != 1) {
						fprintf(stderr, "error reading filelist\n");
						exit(0);
					}

					fp = fopen(dbname, "r");

					if(!fp) {
						printf("error opening a db\n");
						exit(1);
					}
				}
			} else {
				perror("Error");
				exit(0);
			}
		}

	   	//Initialize a and b
		float x2 = target_lat;
		float y2 = target_long;

		/**
		* Transfer data from host to device
		*/
		cudaMemcpy( data, sandbox, (sizeof(char)*REC_WINDOW*REC_LENGTH), cudaMemcpyHostToDevice);

		/**
		* Execute kernel
		*/
		//Compute the execution configuration
		int block_size = 16;
		dim3 dimBlock(block_size);
		dim3 dimGrid( (REC_WINDOW/dimBlock.x) + (!(REC_WINDOW%dimBlock.x)?0:1) );

		//Add a and b, store in c
		euclid<<<dimGrid,dimBlock>>>(data, x2, y2, z_d, REC_WINDOW, REC_LENGTH, LATITUDE_POS);
		cudaThreadSynchronize();
		
		//Copy data from device memory to host memory
		cudaMemcpy( z, z_d, sizeof(float)*REC_WINDOW, cudaMemcpyDeviceToHost );
	  
		/**
		* Update list of nearest neighbors
		*/       
		for(i=0;i< rec_count;i++) {
			float max_dist = -1;
			int max_idx = 0;
			// find a neighbor with greatest dist and take his spot if allowed!
			for( j = 0 ; j < k ; j++ ) {
				if(neighbors[j].dist > max_dist) {
					max_dist = neighbors[j].dist;
					max_idx = j;
				}
			}
			// compare each record with max value to find the nearest neighbor
			if(z[i] < neighbors[max_idx].dist) {
				sandbox[(i+1)*REC_LENGTH-1] = '\0';
			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);
			  	neighbors[max_idx].dist = z[i];
			}
		}
	} //End while
        //Free memory
	free(z);
	cudaFree(data);
	cudaFree(z_d);

	fprintf(stderr, "The %d nearest neighbors are:\n", k);
	FILE* fpo = fopen("result.txt", "w");
	for( j = 0 ; j < k ; j++ ) {
	  if(!(neighbors[j].dist==OPEN)){
		 fprintf(stderr, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);
		 fprintf(fpo, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);
	  }
	}
	fclose(fpo);
	if(goldfile){
		FILE *gold = fopen(goldfile, "r");
		FILE *result = fopen("result.txt", "r");
		int result_error=0;
		while(!feof(gold)&&!feof(result)){
			if (fgetc(gold)!=fgetc(result)) {
				result_error = 1;
				break;
			}
		}
		if((feof(gold)^feof(result)) | result_error) {
			printf("\nFAILED\n");
		} else {
			printf("\nPASSED\n");
		}

		fclose(gold);
		fclose(result);
	}

	free(neighbors);
	fclose(flist);
}
